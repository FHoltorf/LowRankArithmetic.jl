var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LowRankArithmetic","category":"page"},{"location":"#LowRankArithmetic","page":"Home","title":"LowRankArithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LowRankArithmetic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LowRankArithmetic]","category":"page"},{"location":"#LowRankArithmetic.SVDLikeRepresentation","page":"Home","title":"LowRankArithmetic.SVDLikeRepresentation","text":"X = U*S*V'\n\nSVD like factorization of a low rank matrix into factors U ∈ ℝⁿˣʳ, S ∈ ℝʳˣʳ, V ∈ ℝᵐˣʳ. \nThe columns of U span the range of X, the colomuns of V span the co-range of X and S describes the map between\nco-range and range. The factorization is non-unique and U and V need not be orthogonal! \nHowever, often U and V are chosen orthogonal to allow for cheap (pseudo)inversion. In that case, note that\northogonality of U and V is not guaranteed to and in fact will rarely be preserved under the operations that\nare supported (multiplication, addition, etc.). In order to reorthonormalize U and V, simply call `orthonormalize!(X, alg)`\nwhere alg refers to the algorithm used to compute the orthonormalization: \n    * QRFact()\n    * SVDFact()\n    * GradientDescent()\n\n\n\n\n\n","category":"type"},{"location":"#LowRankArithmetic.TwoFactorRepresentation","page":"Home","title":"LowRankArithmetic.TwoFactorRepresentation","text":"X = U*Z'\n\nTwo factor factorization of a low rank matrix into factors U ∈ ℝⁿˣʳ and Z ∈ ℝᵐˣʳ. \nU should span the range of X while Z spans the co-range. The factorization is non-unique and\nU need not be orthogonal! However, U is often chosen orthogonal for cheap (pseudo)inversion. In that case,\nnote that orthogonality of U is not guaranteed to and in fact will rarely be preserved under the operations that\nare supported (multiplication, addition, etc.). In order to reorthonormalize U, simply call `orthonormalize!(X, alg)`\nwhere alg refers to the algorithm used to compute the orthonormalization: \n    * GradientDescent() \n    * QRFact()\n    * SVDFact()\n\n\n\n\n\n","category":"type"}]
}
